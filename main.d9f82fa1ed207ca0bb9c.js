(self.webpackChunkbrush_renderer=self.webpackChunkbrush_renderer||[]).push([[179],{37:(e,t,n)=>{"use strict";var r=n(684),i=n(893),o=n(413);const a=n.p+"d098bcb6bef47079d1051933ec54f6dc.fbx";var s=n(589),u=n(602);const d="\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    #include <beginnormal_vertex>\n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <begin_vertex>\n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <project_vertex>\n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n}\n",l="\nuniform bool useV;\nvarying vec2 vUv;\n\nconst vec3 black = vec3(0.);\nconst vec3 white = vec3(1.);\n\nvoid main()\n{\n    float x = vUv.x;\n    if (useV) x = vUv.y;\n    gl_FragColor = vec4(mix(black, white, x), 1.0);\n}\n",h=n.p+"a1d209fc31525618e3e583994cf29b39.png";var c=function(e,t,n){u.w.call(this),this.scene=e,this.camera=t,this.needsSwap=!1,this.NB_BRUSHES=n.number,this.drawBrushesOverScene=n.drawOver,this.WIDTH=window.innerWidth,this.HEIGHT=window.innerHeight,this.depthTexture=new r.$YQ(this.WIDTH,this.HEIGHT),this.depthTexture.format=r.qkB,this.depthTexture.type=r.LsT,this.colorTarget=new r.dd2(this.WIDTH,this.HEIGHT,{format:r.UCm,encoding:r.knz,minFilter:r.TyD,magFilter:r.TyD,generateMipmaps:!1,stencilBuffer:!1,depthBuffer:!0,depthTexture:this.depthTexture}),this.xFieldTarget=new r.dd2(this.WIDTH,this.HEIGHT,{format:r.UCm,encoding:r.knz,minFilter:r.TyD,magFilter:r.TyD,generateMipmaps:!1,stencilBuffer:!1,depthBuffer:!1}),this.uvGradXMaterial=new r.jyz({lights:!0,uniforms:r.rDY.merge([r.Vj0.lambert.uniforms,{useV:{value:"grad v"===n.orientation}}]),vertexShader:"\n                #include <common>\n                ".concat(d,"\n            "),fragmentShader:l,transparent:!0}),this.uvGradXMaterial2=new r.jyz({lights:!0,uniforms:r.rDY.merge([r.Vj0.lambert.uniforms,{useV:{value:"grad v"===n.orientation}}]),vertexShader:"\n                #include <common>\n                ".concat(d,"\n            "),fragmentShader:l,skinning:!0,transparent:!0}),this.sceneBrush=new r.xsS,this.cameraBrush=new r.cPb(40,this.WIDTH/this.HEIGHT,1,1e4),this.cameraBrush.position.z=300,this.brushMaterial=new r.jyz({uniforms:{resolution:{value:new r.FM8(this.WIDTH*window.devicePixelRatio,this.HEIGHT*window.devicePixelRatio)},brushTexture:{value:(new r.dpR).load(h)},colorTexture:{value:this.colorTarget.texture},depthTexture:{value:this.colorTarget.depthTexture},xFieldTexture:{value:this.xFieldTarget.texture},horizontalStrokes:{value:"horizontal"===n.brushOrientation},attenuation:{value:n.attenuation},pointSize:{value:n.size}},vertexShader:"\nuniform bool horizontalStrokes;\nuniform float attenuation;\nuniform float pointSize;\nuniform vec2 resolution;\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform sampler2D xFieldTexture;\n\nvarying vec4 vColor;\nvarying float vRotation;\nvarying float vPointSize;\nvarying float depth;\n\n// Sobel kernel\nconst mat3 Gx = mat3(-1., -2., -1., 0., 0., 0., 1., 2., 1.);\nconst mat3 Gy = mat3(-1., 0., 1., -2., 0., 2., -1., 0., 1.);\n\nvoid main()\n{\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vec4 mvpPosition = projectionMatrix * mvPosition;\n    vec3 ndc = mvpPosition.xyz / mvpPosition.w;\n    vec2 viewportCoords = ndc.xy * 0.5 + 0.5;\n\n    // Compute color\n    vColor = texture2D(colorTexture, viewportCoords);\n\n    // Rotation from grad of uv field\n    float mag = 1.;\n    if (horizontalStrokes) {\n        vRotation = 0.;\n    } else {\n        vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n        // Sobel convolution\n        // c1\n        float tx0y0 = texture2D(xFieldTexture, viewportCoords + texel * vec2(-1., -1.)).r;\n        float tx0y1 = texture2D(xFieldTexture, viewportCoords + texel * vec2(-1., 0.)).r;\n        float tx0y2 = texture2D(xFieldTexture, viewportCoords + texel * vec2(-1., 1.)).r;\n        // c2\n        float tx1y0 = texture2D(xFieldTexture, viewportCoords + texel * vec2(0., -1.)).r;\n        float tx1y1 = texture2D(xFieldTexture, viewportCoords + texel * vec2(0., 0.)).r;\n        float tx1y2 = texture2D(xFieldTexture, viewportCoords + texel * vec2(0., 1.)).r;\n        // c3\n        float tx2y0 = texture2D(xFieldTexture, viewportCoords + texel * vec2(1., -1.)).r;\n        float tx2y1 = texture2D(xFieldTexture, viewportCoords + texel * vec2(1., 0.)).r;\n        float tx2y2 = texture2D(xFieldTexture, viewportCoords + texel * vec2(1., 1.)).r;\n        // grad\n        float gradX =\n            Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +\n            Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +\n            Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;\n        float gradY =\n            Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +\n            Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +\n            Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;\n        mag = sqrt((gradX * gradX) + (gradY * gradY));\n        vRotation = atan(gradX, gradY);\n\n        // if (mag < 0.05) vRotation = 0.;\n        // if (mag > 0.05) vRotation += 3.1415 / 4.0;\n    }\n\n    // TODO put here different brush textures\n\n    // Point size from depth\n    vPointSize = pointSize; // 40.;\n    depth = 1. - texture2D(depthTexture, viewportCoords).x;\n    // vPointSize *= 1. + 4.0 * pow(depth, 4.0);\n    vPointSize *= 1. + pow(2., attenuation) * pow(depth, attenuation);\n    vPointSize *= (1.0 - mag);\n\n    // Point size\n    gl_PointSize = vPointSize * ( 300.0 / length( mvPosition.xyz ) );\n    vPointSize = gl_PointSize;\n\n    // Output\n    gl_Position = mvpPosition;\n}\n",fragmentShader:"\nuniform sampler2D brushTexture;\n\nvarying vec4 vColor;\nvarying float vRotation;\nvarying float vPointSize;\nvarying float depth;\n\nvoid main()\n{\n    if (depth == 0.) discard;\n    float mid = 0.5;\n    vec2 rotated = vec2(\n        cos(vRotation) * (gl_PointCoord.x - mid) + sin(vRotation) * (gl_PointCoord.y - mid) + mid,\n        cos(vRotation) * (gl_PointCoord.y - mid) - sin(vRotation) * (gl_PointCoord.x - mid) + mid\n    );\n    vec4 rotatedTexture = texture2D(brushTexture, rotated);\n    float norm = rotatedTexture.x + rotatedTexture.y + rotatedTexture.z;\n    gl_FragColor = vec4(vColor.xyz, 1.0) * rotatedTexture;\n}\n",blending:r.Xaj,blendEquation:r.Sm8,depthTest:!1,transparent:!0,vertexColors:!1}),this.brushGeometry=new r.u9r;for(var i=[],o=this.WIDTH/this.HEIGHT,a=0;a<this.NB_BRUSHES;++a)i.push(110*(2*Math.random()-1)*o),i.push(110*(2*Math.random()-1)),i.push(0);this.brushGeometry.setAttribute("position",new r.a$l(i,3)),this.particleSystem=new r.woe(this.brushGeometry,this.brushMaterial),this.sceneBrush.add(this.particleSystem),this.clear=!1};c.prototype=Object.assign(Object.create(u.w.prototype),{constructor:c,rebuildParticles:function(e){this.sceneBrush.remove(this.particleSystem),this.NB_BRUSHES=e,this.brushGeometry=new r.u9r;for(var t=this.WIDTH/this.HEIGHT,n=[],i=0;i<this.NB_BRUSHES;++i)n.push(110*(2*Math.random()-1)*t),n.push(110*(2*Math.random()-1)),n.push(0);this.brushGeometry.setAttribute("position",new r.a$l(n,3)),this.particleSystem=new r.woe(this.brushGeometry,this.brushMaterial),this.sceneBrush.add(this.particleSystem)},render:function(e){var t=this,n=e.autoClear;e.autoClear=!1,e.autoClearColor=!1,e.autoClearDepth=!1,e.setRenderTarget(this.colorTarget),e.clearDepth(),e.render(this.scene,this.camera),this.drawBrushesOverScene&&(e.toneMappingExposure=.5,e.setRenderTarget(null),e.render(this.scene,this.camera),e.toneMappingExposure=.8);var r={};this.scene.traverse((function(e){e.isMesh&&!e.isSkinnedMesh?(r[e.uuid]=e.material,e.material=t.uvGradXMaterial):e.isSkinnedMesh&&(r[e.uuid]=e.material,e.material=t.uvGradXMaterial2)})),e.setRenderTarget(this.xFieldTarget),e.render(this.scene,this.camera),this.scene.traverse((function(e){e.isMesh&&(e.material=r[e.uuid])})),e.setRenderTarget(null),e.render(this.sceneBrush,this.cameraBrush),e.autoClear=n}});var v,w,p,x,m,f,g,y,S,b=n(357),T=window.innerWidth,M=window.innerHeight,z=T/M,G=[],P="grad v",C=1e5,R={number:C,orientation:P,size:10,attenuation:2,drawOver:!0,animate:!0},k=!1,D=null;function I(){console.log("Rebuilding brushesâ€¦"),S.rebuildParticles(R.number)}function H(){R.number!==C&&(C=R.number,k?clearTimeout(D):k=!0,D=setTimeout(I,200)),"grad v"===R.brushOrientation?(P=R.brushOrientation,S.uvGradXMaterial.uniforms.useV.value=!0,S.uvGradXMaterial.uniformsNeedUpdate=!0,S.uvGradXMaterial2.uniforms.useV.value=!0,S.uvGradXMaterial2.uniformsNeedUpdate=!0,S.brushMaterial.uniforms.horizontalStrokes.value=!1):"grad u"===R.brushOrientation?(P=R.brushOrientation,S.uvGradXMaterial.uniforms.useV.value=!1,S.uvGradXMaterial.uniformsNeedUpdate=!0,S.uvGradXMaterial2.uniforms.useV.value=!1,S.uvGradXMaterial2.uniformsNeedUpdate=!0,S.brushMaterial.uniforms.horizontalStrokes.value=!1):"horizontal"===R.brushOrientation&&(S.brushMaterial.uniforms.horizontalStrokes.value=!0),S.brushMaterial.uniforms.attenuation.value=R.attenuation,S.brushMaterial.uniforms.pointSize.value=R.size,S.brushMaterial.uniformsNeedUpdate=!0,S.drawBrushesOverScene=R.drawOver}var _,B,E,F,j,X=[],K=0,O=window.performance.now();function W(e,t){return e>t}!function(){(p=new r.CP7({antialias:!0,logarithmicDepthBuffer:!0})).toneMapping=r.LY2,p.toneMappingExposure=.8,p.outputEncoding=r.knz,p.setPixelRatio(window.devicePixelRatio),p.setSize(T,M),document.body.appendChild(p.domElement),p.shadowMap.enabled=!0,p.shadowMap.type=r.ntZ;var e=function(){v.aspect=window.innerWidth/window.innerHeight,v.updateProjectionMatrix(),p.setSize(window.innerWidth,window.innerHeight)};window.addEventListener("resize",e,!1),window.addEventListener("orientationchange",e,!1)}(),w=new r.xsS,(v=new r.cPb(90,z,.1,5e3)).position.set(0,0,30),w.add(v),m=new r.Pa4(1,10,10),(f=new r.cek(16777215,.5)).position.copy(m),f.castShadow=!0,f.shadow.camera.near=1,f.shadow.camera.far=100,f.shadow.bias=1e-4,f.shadow.radius=10,f.shadow.mapSize.width=1024,f.shadow.mapSize.height=512,[].push(f),w.add(f),g=new r.Mig(4210752),w.add(g),x=new i.z(v,p.domElement),y=new s.x(p),S=new c(w,v,R),y.addPass(S),(B=(_=new b.XS).addFolder("Brush settings")).add(R,"number",1e3,15e4,100).onChange((function(e){R.number=e,H()})),B.add(R,"orientation").options(["horizontal","grad u","grad v"]).onChange((function(e){R.brushOrientation=e,H()})),B.add(R,"size",1,20,1).onChange((function(e){R.size=e,H()})),B.add(R,"attenuation",1,3,.1).onChange((function(e){R.attenuation=e,H()})),B.add(R,"drawOver").onChange((function(e){R.drawOver=e,H()})),B.add(R,"animate").onChange((function(e){R.animate=e,H()})),_.open(),(E=[new r.Ilk(1,1,1),new r.Ilk(1,1,1),new r.Ilk(1,.15,.05),new r.Ilk(.3,1,.08),new r.Ilk(1,1,1)],j=0,(F=[]).push(new r.Kj0(new r.BKK(50,50),new r.xoR({color:E[j],side:r.Wl3}))),F[j].position.set(0,-25,0),F[j].rotation.x=-Math.PI/2,F[j++].receiveShadow=!0,F.push(new r.Kj0(new r.BKK(50,50),new r.xoR({color:E[j],side:r.Wl3}))),F[j].position.set(0,0,-25),F[j++].receiveShadow=!0,F.push(new r.Kj0(new r.BKK(50,50),new r.xoR({color:E[j],side:r.Wl3}))),F[j].position.set(-25,0,0),F[j].rotation.y=Math.PI/2,F[j++].receiveShadow=!0,F.push(new r.Kj0(new r.BKK(50,50),new r.xoR({color:E[j],side:r.Wl3}))),F[j].position.set(25,0,0),F[j].rotation.y=-Math.PI/2,F[j++].receiveShadow=!0,F.push(new r.Kj0(new r.BKK(50,50),new r.xoR({color:E[j],side:r.Wl3}))),F[j].position.set(0,0,25),F[j].rotation.y=Math.PI,F[j++].receiveShadow=!0,F).forEach((function(e){return w.add(e)})),function(){var e=[new r.Ilk(.05,.3,1),16776960,16776960,new r.Ilk(.05,.3,1),16776960],t=0,n=new r.Kj0(new r.XZw(10,3,200,50),new r.xoR({color:e[t++],specular:1}));n.scale.multiplyScalar(.6),n.position.set(-15,-10,20),n.castShadow=!0,n.receiveShadow=!0;var i=new r.Kj0(new r.XZw(10,3,200,50),new r.xoR({color:e[t++],specular:1}));i.scale.multiplyScalar(.2),i.rotation.set(0,Math.PI/2,0),i.position.set(15,-5,12),i.castShadow=!0,i.receiveShadow=!0;var o=new r.Kj0(new r.XZw(10,3,200,128),new r.xoR({color:e[t++],specular:1}));o.scale.multiplyScalar(.5),o.rotation.set(0,Math.PI/2,Math.PI/2),o.rotation.set(0,0,Math.PI/2),o.position.set(-15,-5,15),o.castShadow=!0,o.receiveShadow=!0;var a=new r.Kj0(new r.Aip(5,32,32),new r.xoR({color:e[t++],specular:1}));a.position.set(-10,-20,15),a.castShadow=!0,a.receiveShadow=!0;var s=new r.Kj0(new r.Aip(5,32,32),new r.xoR({color:e[t++],specular:1}));return s.scale.multiplyScalar(1.5),s.position.set(-10,-5,-15),s.castShadow=!0,s.receiveShadow=!0,[i,o]}().forEach((function(e){w.add(e),X.push(e)})),function(e,t){(new o.y).load(a,(function(n){var i=new r.Xcj(n);i.clipAction(n.animations[0]).play(),function(e){e.scale.multiplyScalar(.2),e.position.set(0,-25,0)}(n);var o=new r.ZAu;o.add(n),n.traverse((function(e){e.isMesh&&(e.castShadow=!0,e.receiveShadow=!0,e.material.color.r<.1?e.material=new r.xoR({color:new r.Ilk(.05,.3,1),skinning:!0}):e.material=new r.xoR({color:new r.Ilk(0,0,0),skinning:!0}))})),e.add(o),t.push(i)}))}(w,G),function e(){if(requestAnimationFrame(e),R.animate){var t=window.performance.now(),n=t-O;O=t,K+=.001*n,m.x=10*Math.sin(K),m.z=10+10*Math.cos(K)+4,m.y=10+Math.cos(K)*Math.sin(K)*10;for(var r=0;r<X.length;++r){var i=X[r];i.rotation.x+=.02*W(r%3,0),i.rotation.y+=.02*W((r+1)%3,0),i.rotation.z+=.02*W((r+2)%3,0)}f.position.copy(m),G.length&&G.forEach((function(e){return e.update(n/1e3)}))}else O=window.performance.now();x.update(),y.render()}()}},0,[[37,666,216]]]);