(self.webpackChunkbrush_renderer=self.webpackChunkbrush_renderer||[]).push([[179],{37:(e,t,n)=>{"use strict";var r=n(684),i=n(893),o=n(413);const a=n.p+"d098bcb6bef47079d1051933ec54f6dc.fbx";var s=n(589),u=n(602);const d="\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    #include <beginnormal_vertex>\n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <begin_vertex>\n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <project_vertex>\n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n}\n",l="\nuniform bool useV;\nvarying vec2 vUv;\n\nconst vec3 black = vec3(0.);\nconst vec3 white = vec3(1.);\n\nvoid main()\n{\n    float x = vUv.x;\n    if (useV) x = vUv.y;\n    gl_FragColor = vec4(mix(black, white, x), 1.0);\n}\n",h=n.p+"a1d209fc31525618e3e583994cf29b39.png";var c=function(e,t,n){u.w.call(this),this.scene=e,this.camera=t,this.needsSwap=!1,this.NB_BRUSHES=n.number,this.drawBrushesOverScene=n.drawOver,this.WIDTH=window.innerWidth,this.HEIGHT=window.innerHeight,this.depthTexture=new r.$YQ(this.WIDTH,this.HEIGHT),this.depthTexture.format=r.qkB,this.depthTexture.type=r.LsT,this.colorTarget=new r.dd2(this.WIDTH,this.HEIGHT,{format:r.UCm,minFilter:r.TyD,magFilter:r.TyD,generateMipmaps:!1,stencilBuffer:!1,depthBuffer:!0,depthTexture:this.depthTexture}),this.xFieldTarget=new r.dd2(this.WIDTH,this.HEIGHT,{format:r.UCm,minFilter:r.TyD,magFilter:r.TyD,generateMipmaps:!1,stencilBuffer:!1,depthBuffer:!1}),this.uvGradXMaterial=new r.jyz({lights:!0,uniforms:r.rDY.merge([r.Vj0.lambert.uniforms,{useV:{value:"grad v"===n.brushOrientation}}]),vertexShader:"\n                #include <common>\n                ".concat(d,"\n            "),fragmentShader:l,transparent:!0}),this.uvGradXMaterial2=new r.jyz({lights:!0,uniforms:r.rDY.merge([r.Vj0.lambert.uniforms,{useV:{value:"grad v"===n.brushOrientation}}]),vertexShader:"\n                #include <common>\n                ".concat(d,"\n            "),fragmentShader:l,skinning:!0,transparent:!0}),this.sceneBrush=new r.xsS,this.cameraBrush=new r.cPb(40,this.WIDTH/this.HEIGHT,1,1e4),this.cameraBrush.position.z=300,this.brushMaterial=new r.jyz({uniforms:{resolution:{value:new r.FM8(this.WIDTH*window.devicePixelRatio,this.HEIGHT*window.devicePixelRatio)},brushTexture:{value:(new r.dpR).load(h)},colorTexture:{value:this.colorTarget.texture},depthTexture:{value:this.colorTarget.depthTexture},xFieldTexture:{value:this.xFieldTarget.texture},horizontalStrokes:{value:"horizontal"===n.brushOrientation},attenuation:{value:n.attenuation},pointSize:{value:n.size}},vertexShader:"\nuniform bool horizontalStrokes;\nuniform float attenuation;\nuniform float pointSize;\nuniform vec2 resolution;\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform sampler2D xFieldTexture;\n\nvarying vec4 vColor;\nvarying float vRotation;\nvarying float vPointSize;\nvarying float depth;\n\n// Sobel kernel\nconst mat3 Gx = mat3(-1., -2., -1., 0., 0., 0., 1., 2., 1.);\nconst mat3 Gy = mat3(-1., 0., 1., -2., 0., 2., -1., 0., 1.);\n\nvoid main()\n{\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vec4 mvpPosition = projectionMatrix * mvPosition;\n    vec3 ndc = mvpPosition.xyz / mvpPosition.w;\n    vec2 viewportCoords = ndc.xy * 0.5 + 0.5;\n\n    // Compute color\n    vColor = texture2D(colorTexture, viewportCoords);\n\n    // Rotation from grad of uv field\n    if (horizontalStrokes) {\n        vRotation = 0.;\n    } else {\n        vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n        // Sobel convolution\n        // c1\n        float tx0y0 = texture2D(xFieldTexture, viewportCoords + texel * vec2(-1., -1.)).r;\n        float tx0y1 = texture2D(xFieldTexture, viewportCoords + texel * vec2(-1., 0.)).r;\n        float tx0y2 = texture2D(xFieldTexture, viewportCoords + texel * vec2(-1., 1.)).r;\n        // c2\n        float tx1y0 = texture2D(xFieldTexture, viewportCoords + texel * vec2(0., -1.)).r;\n        float tx1y1 = texture2D(xFieldTexture, viewportCoords + texel * vec2(0., 0.)).r;\n        float tx1y2 = texture2D(xFieldTexture, viewportCoords + texel * vec2(0., 1.)).r;\n        // c3\n        float tx2y0 = texture2D(xFieldTexture, viewportCoords + texel * vec2(1., -1.)).r;\n        float tx2y1 = texture2D(xFieldTexture, viewportCoords + texel * vec2(1., 0.)).r;\n        float tx2y2 = texture2D(xFieldTexture, viewportCoords + texel * vec2(1., 1.)).r;\n        // grad\n        float gradX =\n            Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +\n            Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +\n            Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;\n        float gradY =\n            Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +\n            Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +\n            Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;\n        float mag = sqrt((gradX * gradX) + (gradY * gradY));\n        vRotation = atan(gradX, gradY);\n\n        // if (mag < 0.05) vRotation = 0.;\n        // if (mag > 0.05) vRotation += 3.1415 / 4.0;\n    }\n\n    // TODO put here different brush textures\n\n    // Point size from depth\n    vPointSize = pointSize; // 40.;\n    depth = 1. - texture2D(depthTexture, viewportCoords).x;\n    // vPointSize *= 1. + 4.0 * pow(depth, 4.0);\n    vPointSize *= 1. + pow(2., attenuation) * pow(depth, attenuation);\n\n    // Point size\n    gl_PointSize = vPointSize * ( 300.0 / length( mvPosition.xyz ) );\n    vPointSize = gl_PointSize;\n\n    // Output\n    gl_Position = mvpPosition;\n}\n",fragmentShader:"\nuniform sampler2D brushTexture;\n\nvarying vec4 vColor;\nvarying float vRotation;\nvarying float vPointSize;\nvarying float depth;\n\nvoid main()\n{\n    if (depth == 0.) discard;\n    float mid = 0.5;\n    vec2 rotated = vec2(\n        cos(vRotation) * (gl_PointCoord.x - mid) + sin(vRotation) * (gl_PointCoord.y - mid) + mid,\n        cos(vRotation) * (gl_PointCoord.y - mid) - sin(vRotation) * (gl_PointCoord.x - mid) + mid\n    );\n    vec4 rotatedTexture = texture2D(brushTexture, rotated);\n    float norm = rotatedTexture.x + rotatedTexture.y + rotatedTexture.z;\n    gl_FragColor = vec4(vColor.xyz, 1.0) * rotatedTexture;\n}\n",blending:r.Xaj,blendEquation:r.Sm8,depthTest:!1,transparent:!0,vertexColors:!1}),this.brushGeometry=new r.u9r;for(var i=[],o=0;o<this.NB_BRUSHES;++o)i.push(200*(2*Math.random()-1)),i.push(200*(2*Math.random()-1)),i.push(0);this.brushGeometry.setAttribute("position",new r.a$l(i,3)),this.particleSystem=new r.woe(this.brushGeometry,this.brushMaterial),this.sceneBrush.add(this.particleSystem),this.clear=!1};c.prototype=Object.assign(Object.create(u.w.prototype),{constructor:c,rebuildParticles:function(e){this.sceneBrush.remove(this.particleSystem),this.NB_BRUSHES=e,this.brushGeometry=new r.u9r;for(var t=[],n=0;n<this.NB_BRUSHES;++n)t.push(200*(2*Math.random()-1)),t.push(200*(2*Math.random()-1)),t.push(0);this.brushGeometry.setAttribute("position",new r.a$l(t,3)),this.particleSystem=new r.woe(this.brushGeometry,this.brushMaterial),this.sceneBrush.add(this.particleSystem)},render:function(e){var t=this,n=e.autoClear;e.autoClear=!1,e.autoClearColor=!1,e.autoClearDepth=!1,e.setRenderTarget(this.colorTarget),e.clear(),e.render(this.scene,this.camera),this.drawBrushesOverScene&&(e.setRenderTarget(null),e.render(this.scene,this.camera));var r={};this.scene.traverse((function(e){e.isMesh&&!e.isSkinnedMesh?(r[e.uuid]=e.material,e.material=t.uvGradXMaterial):e.isSkinnedMesh&&(r[e.uuid]=e.material,e.material=t.uvGradXMaterial2)})),e.setRenderTarget(this.xFieldTarget),e.render(this.scene,this.camera),this.scene.traverse((function(e){e.isMesh&&(e.material=r[e.uuid])})),e.setRenderTarget(null),e.render(this.sceneBrush,this.cameraBrush),e.autoClear=n}});var v,x,w,p,m,f,y,g,S,b=n(357),T=window.innerWidth,M=window.innerHeight,z=T/M,G=[],P="grad v",C=1e5,R={number:C,orientation:P,size:12,attenuation:2,drawOver:!0},_=!1,B=null;function D(){console.log("Rebuilding brushesâ€¦"),S.rebuildParticles(R.number)}function H(){R.number!==C&&(C=R.number,_?clearTimeout(B):_=!0,B=setTimeout(D,200)),"grad v"===R.brushOrientation?(P=R.brushOrientation,S.uvGradXMaterial.uniforms.useV.value=!0,S.uvGradXMaterial.uniformsNeedUpdate=!0,S.uvGradXMaterial2.uniforms.useV.value=!0,S.uvGradXMaterial2.uniformsNeedUpdate=!0,S.brushMaterial.uniforms.horizontalStrokes.value=!1):"grad u"===R.brushOrientation?(P=R.brushOrientation,S.uvGradXMaterial.uniforms.useV.value=!1,S.uvGradXMaterial.uniformsNeedUpdate=!0,S.uvGradXMaterial2.uniforms.useV.value=!1,S.uvGradXMaterial2.uniformsNeedUpdate=!0,S.brushMaterial.uniforms.horizontalStrokes.value=!1):"horizontal"===R.brushOrientation&&(S.brushMaterial.uniforms.horizontalStrokes.value=!0),S.brushMaterial.uniforms.attenuation.value=R.attenuation,S.brushMaterial.uniforms.pointSize.value=R.size,S.brushMaterial.uniformsNeedUpdate=!0,S.drawBrushesOverScene=R.drawOver}var F,j,k,O,X=0,I=window.performance.now();!function(){(w=new r.CP7({antialias:!0,logarithmicDepthBuffer:!0})).setPixelRatio(window.devicePixelRatio),w.setSize(T,M),document.body.appendChild(w.domElement),w.shadowMap.enabled=!0,w.shadowMap.type=r.ntZ;var e=function(){v.aspect=window.innerWidth/window.innerHeight,v.updateProjectionMatrix(),w.setSize(window.innerWidth,window.innerHeight)};window.addEventListener("resize",e,!1),window.addEventListener("orientationchange",e,!1)}(),x=new r.xsS,(v=new r.cPb(90,z,.1,5e3)).position.set(0,0,30),x.add(v),m=new r.Pa4(1,1,1),(f=new r.cek(16777215,1)).position.copy(m),f.castShadow=!0,f.shadow.camera.near=1,f.shadow.camera.far=100,f.shadow.bias=1e-4,f.shadow.mapSize.width=1024,f.shadow.mapSize.height=512,[].push(f),x.add(f),y=new r.Mig(4210752),x.add(y),p=new i.z(v,w.domElement),g=new s.x(w),S=new c(x,v,R),g.addPass(S),(j=(F=new b.XS).addFolder("Brush settings")).add(R,"number",1e3,1e5,100).onChange((function(e){R.number=e,H()})),j.add(R,"orientation").options(["horizontal","grad u","grad v"]).onChange((function(e){R.brushOrientation=e,H()})),j.add(R,"size",1,20,1).onChange((function(e){R.size=e,H()})),j.add(R,"attenuation",1,3,.1).onChange((function(e){R.attenuation=e,H()})),j.add(R,"drawOver").onChange((function(e){R.drawOver=e,H()})),F.open(),(O=0,(k=[]).push(new r.Kj0(new r.BKK(50,50),new r.xoR({color:16711680,side:r.Wl3}))),k[O].position.set(0,-25,0),k[O].rotation.x=-Math.PI/2,k[O++].receiveShadow=!0,k.push(new r.Kj0(new r.BKK(50,50),new r.xoR({color:255,side:r.Wl3}))),k[O].position.set(0,0,-25),k[O++].receiveShadow=!0,k.push(new r.Kj0(new r.BKK(50,50),new r.xoR({color:65280,side:r.Wl3}))),k[O].position.set(-25,0,0),k[O].rotation.y=Math.PI/2,k[O++].receiveShadow=!0,k.push(new r.Kj0(new r.BKK(50,50),new r.xoR({color:65280,side:r.Wl3}))),k[O].position.set(25,0,0),k[O].rotation.y=-Math.PI/2,k[O++].receiveShadow=!0,k.push(new r.Kj0(new r.BKK(50,50),new r.xoR({color:255,side:r.Wl3}))),k[O].position.set(0,0,25),k[O].rotation.y=Math.PI,k[O++].receiveShadow=!0,k).forEach((function(e){return x.add(e)})),function(){var e=[16711680,11206400,11184640,41120,16776960],t=0,n=new r.Kj0(new r.XZw(10,3,200,50),new r.xoR({color:e[t++],specular:1}));n.scale.multiplyScalar(.6),n.position.set(-5,-10,5),n.castShadow=!0,n.receiveShadow=!0;var i=new r.Kj0(new r.XZw(10,3,200,50),new r.xoR({color:e[t++],specular:1}));i.scale.multiplyScalar(.5),i.rotation.set(0,Math.PI/2,0),i.position.set(15,5,10),i.castShadow=!0,i.receiveShadow=!0;var o=new r.Kj0(new r.XZw(10,3,200,128),new r.xoR({color:e[t++],specular:1}));o.scale.multiplyScalar(.5),o.rotation.set(0,Math.PI/2,Math.PI/2),o.rotation.set(0,0,Math.PI/2),o.position.set(-15,5,10),o.castShadow=!0,o.receiveShadow=!0;var a=new r.Kj0(new r.Aip(5,32,32),new r.xoR({color:e[t++],specular:1}));a.position.set(5,-15,15),a.castShadow=!0,a.receiveShadow=!0;var s=new r.Kj0(new r.Aip(5,32,32),new r.xoR({color:e[t++],specular:1}));return s.scale.multiplyScalar(1.5),s.position.set(-10,-5,-15),s.castShadow=!0,s.receiveShadow=!0,[n,i,o,a,s]}().forEach((function(e){x.add(e)})),function(e,t){(new o.y).load(a,(function(n){var i=new r.Xcj(n);i.clipAction(n.animations[0]).play(),function(e){e.scale.multiplyScalar(.2),e.position.set(5,-25,-10)}(n);var o=new r.ZAu;o.add(n),n.traverse((function(e){e.isMesh&&(e.castShadow=!0,e.receiveShadow=!0)})),e.add(o),t.push(i)}))}(x,G),function e(){requestAnimationFrame(e);var t=window.performance.now(),n=t-I;I=t,X+=.001*n,m.x=10*Math.sin(X),m.z=10*Math.cos(X)+4,m.y=Math.cos(X)*Math.sin(X)*10,f.position.copy(m),G.length&&G.forEach((function(e){return e.update(n/1e3)})),p.update(),g.render()}()}},0,[[37,666,216]]]);