(self.webpackChunkbrush_renderer=self.webpackChunkbrush_renderer||[]).push([[179],{37:(e,t,n)=>{"use strict";var o=n(684),i=n(893),r=n(413);const a=n.p+"d098bcb6bef47079d1051933ec54f6dc.fbx";var s=n(589),u=n(602);const d=n.p+"a1d209fc31525618e3e583994cf29b39.png";var l=function(e,t,n){u.w.call(this),this.scene=e,this.camera=t,this.needsSwap=!1,this.NB_BRUSHES=n,this.WIDTH=window.innerWidth,this.HEIGHT=window.innerHeight,this.depthTexture=new o.$YQ(this.WIDTH,this.HEIGHT),this.depthTexture.format=o.qkB,this.depthTexture.type=o.LsT,this.colorTarget=new o.dd2(this.WIDTH,this.HEIGHT,{format:o.UCm,minFilter:o.TyD,magFilter:o.TyD,generateMipmaps:!1,stencilBuffer:!1,depthBuffer:!0,depthTexture:this.depthTexture}),this.xFieldTarget=new o.dd2(this.WIDTH,this.HEIGHT,{format:o.UCm,minFilter:o.TyD,magFilter:o.TyD,generateMipmaps:!1,stencilBuffer:!1,depthBuffer:!1}),this.uvGradXMaterial=new o.jyz({uniforms:{useV:{value:!1}},vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\nuniform bool useV;\n\nvarying vec2 vUv;\n\nconst vec3 black = vec3(0.);\nconst vec3 white = vec3(1.);\n\nvoid main()\n{\n    float x = vUv.x;\n    if (useV) x = vUv.y;\n    gl_FragColor = vec4(mix(black, white, x), 1.0);\n}\n"}),this.sceneBrush=new o.xsS,this.cameraBrush=new o.cPb(40,this.WIDTH/this.HEIGHT,1,1e4),this.cameraBrush.position.z=300,this.brushMaterial=new o.jyz({uniforms:{resolution:{value:new o.FM8(this.WIDTH*window.devicePixelRatio,this.HEIGHT*window.devicePixelRatio)},brushTexture:{value:(new o.dpR).load(d)},colorTexture:{value:this.colorTarget.texture},depthTexture:{value:this.colorTarget.depthTexture},xFieldTexture:{value:this.xFieldTarget.texture},horizontalStrokes:{value:!1},attenuation:{value:2},pointSize:{value:20}},vertexShader:"\nuniform bool horizontalStrokes;\nuniform float attenuation;\nuniform float pointSize;\nuniform vec2 resolution;\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform sampler2D xFieldTexture;\n\nvarying vec4 vColor;\nvarying float vRotation;\nvarying float vPointSize;\nvarying float depth;\n\n// Sobel kernel\nconst mat3 Gx = mat3(-1., -2., -1., 0., 0., 0., 1., 2., 1.);\nconst mat3 Gy = mat3(-1., 0., 1., -2., 0., 2., -1., 0., 1.);\n\nvoid main()\n{\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    vec4 mvpPosition = projectionMatrix * mvPosition;\n    vec3 ndc = mvpPosition.xyz / mvpPosition.w;\n    vec2 viewportCoords = ndc.xy * 0.5 + 0.5;\n\n    // Compute color\n    vColor = texture2D(colorTexture, viewportCoords);\n\n    // Rotation from grad of uv field\n    if (horizontalStrokes) {\n        vRotation = 0.;\n    } else {\n        vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n        // Sobel convolution\n        // c1\n        float tx0y0 = texture2D(xFieldTexture, viewportCoords + texel * vec2(-1., -1.)).r;\n        float tx0y1 = texture2D(xFieldTexture, viewportCoords + texel * vec2(-1., 0.)).r;\n        float tx0y2 = texture2D(xFieldTexture, viewportCoords + texel * vec2(-1., 1.)).r;\n        // c2\n        float tx1y0 = texture2D(xFieldTexture, viewportCoords + texel * vec2(0., -1.)).r;\n        float tx1y1 = texture2D(xFieldTexture, viewportCoords + texel * vec2(0., 0.)).r;\n        float tx1y2 = texture2D(xFieldTexture, viewportCoords + texel * vec2(0., 1.)).r;\n        // c3\n        float tx2y0 = texture2D(xFieldTexture, viewportCoords + texel * vec2(1., -1.)).r;\n        float tx2y1 = texture2D(xFieldTexture, viewportCoords + texel * vec2(1., 0.)).r;\n        float tx2y2 = texture2D(xFieldTexture, viewportCoords + texel * vec2(1., 1.)).r;\n        // grad\n        float gradX =\n            Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +\n            Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +\n            Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;\n        float gradY =\n            Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +\n            Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +\n            Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;\n        float mag = sqrt((gradX * gradX) + (gradY * gradY));\n        vRotation = atan(gradX, gradY);\n    }\n\n    // TODO different brush textures\n\n    // Point size from depth\n    vPointSize = pointSize; // 40.;\n    depth = 1. - texture2D(depthTexture, viewportCoords).x;\n    // vPointSize *= 1. + 4.0 * pow(depth, 4.0);\n    vPointSize *= 1. + pow(2., attenuation) * pow(depth, attenuation);\n\n    // Point size\n    gl_PointSize = vPointSize * ( 300.0 / length( mvPosition.xyz ) );\n    vPointSize = gl_PointSize;\n\n    // Output\n    gl_Position = mvpPosition;\n}\n",fragmentShader:"\nuniform sampler2D brushTexture;\n\nvarying vec4 vColor;\nvarying float vRotation;\nvarying float vPointSize;\nvarying float depth;\n\nvoid main()\n{\n    if (depth == 0.) discard;\n    float mid = 0.5;\n    vec2 rotated = vec2(\n        cos(vRotation) * (gl_PointCoord.x - mid) + sin(vRotation) * (gl_PointCoord.y - mid) + mid,\n        cos(vRotation) * (gl_PointCoord.y - mid) - sin(vRotation) * (gl_PointCoord.x - mid) + mid\n    );\n    vec4 rotatedTexture = texture2D(brushTexture, rotated);\n    float norm = rotatedTexture.x + rotatedTexture.y + rotatedTexture.z;\n    gl_FragColor = vec4(vColor.xyz, 1.0) * rotatedTexture;\n}\n",blending:o.Xaj,blendEquation:o.Sm8,depthTest:!1,transparent:!0,vertexColors:!1}),this.brushGeometry=new o.u9r;for(var i=[],r=0;r<this.NB_BRUSHES;++r)i.push(200*(2*Math.random()-1)),i.push(200*(2*Math.random()-1)),i.push(0);this.brushGeometry.setAttribute("position",new o.a$l(i,3)),this.particleSystem=new o.woe(this.brushGeometry,this.brushMaterial),this.sceneBrush.add(this.particleSystem),this.clear=!1};l.prototype=Object.assign(Object.create(u.w.prototype),{constructor:l,rebuildParticles:function(e){this.sceneBrush.remove(this.particleSystem),this.NB_BRUSHES=e,this.brushGeometry=new o.u9r;for(var t=[],n=0;n<this.NB_BRUSHES;++n)t.push(200*(2*Math.random()-1)),t.push(200*(2*Math.random()-1)),t.push(0);this.brushGeometry.setAttribute("position",new o.a$l(t,3)),this.particleSystem=new o.woe(this.brushGeometry,this.brushMaterial),this.sceneBrush.add(this.particleSystem)},render:function(e){var t=e.autoClear;e.autoClear=!1,e.autoClearColor=!1,e.autoClearDepth=!1,e.setRenderTarget(this.colorTarget),e.clear(),e.render(this.scene,this.camera);var n=this.scene.overrideMaterial;this.scene.overrideMaterial=this.uvGradXMaterial,e.setRenderTarget(this.xFieldTarget),e.render(this.scene,this.camera),this.scene.overrideMaterial=n,e.setRenderTarget(null),e.render(this.sceneBrush,this.cameraBrush),e.autoClear=t}});var h,c,v,x,w,p,m,f,y,g=n(357),S=window.innerWidth,b=window.innerHeight,T=S/b,M=[],P="grad u",z=1e5,C={number:z,orientation:P,size:20,attenuation:2},G=!1,R=null;function D(){console.log("Rebuilding brushesâ€¦"),y.rebuildParticles(C.number)}function B(){C.number!==z&&(z=C.number,G?clearTimeout(R):G=!0,R=setTimeout(D,200)),"grad v"===C.brushOrientation?(P=C.brushOrientation,y.uvGradXMaterial.uniforms.useV.value=!0,y.uvGradXMaterial.uniformsNeedUpdate=!0,y.brushMaterial.uniforms.horizontalStrokes.value=!1):"grad u"===C.brushOrientation?(P=C.brushOrientation,y.uvGradXMaterial.uniforms.useV.value=!1,y.uvGradXMaterial.uniformsNeedUpdate=!0,y.brushMaterial.uniforms.horizontalStrokes.value=!1):"horizontal"===C.brushOrientation&&(y.brushMaterial.uniforms.horizontalStrokes.value=!0),y.brushMaterial.uniforms.attenuation.value=C.attenuation,y.brushMaterial.uniforms.pointSize.value=C.size,y.brushMaterial.uniformsNeedUpdate=!0}var H,F,I,K,j=0,E=window.performance.now();!function(){(v=new o.CP7({antialias:!0,logarithmicDepthBuffer:!0})).setPixelRatio(window.devicePixelRatio),v.setSize(S,b),document.body.appendChild(v.domElement),v.shadowMap.enabled=!0,v.shadowMap.type=o.ntZ;var e=function(){h.aspect=window.innerWidth/window.innerHeight,h.updateProjectionMatrix(),v.setSize(window.innerWidth,window.innerHeight)};window.addEventListener("resize",e,!1),window.addEventListener("orientationchange",e,!1)}(),c=new o.xsS,(h=new o.cPb(90,T,.1,5e3)).position.set(0,0,30),c.add(h),w=new o.Pa4(1,1,1),(p=new o.cek(16777215,1)).position.copy(w),p.castShadow=!0,p.shadow.camera.near=1,p.shadow.camera.far=100,p.shadow.bias=1e-4,p.shadow.mapSize.width=1024,p.shadow.mapSize.height=512,[].push(p),c.add(p),m=new o.Mig(4210752),c.add(m),x=new i.z(h,v.domElement),f=new s.x(v),y=new l(c,h,C.number),f.addPass(y),(F=(H=new g.XS).addFolder("Brush settings")).add(C,"number",1e3,1e5,100).onChange((function(e){C.number=e,B()})),F.add(C,"orientation").options(["horizontal","grad u","grad v"]).onChange((function(e){C.brushOrientation=e,B()})),F.add(C,"size",1,20,1).onChange((function(e){C.size=e,B()})),F.add(C,"attenuation",1,3,.1).onChange((function(e){C.attenuation=e,B()})),H.open(),(K=0,(I=[]).push(new o.Kj0(new o.BKK(50,50),new o.xoR({color:16711680,side:o.Wl3}))),I[K].position.set(0,-25,0),I[K].rotation.x=-Math.PI/2,I[K++].receiveShadow=!0,I.push(new o.Kj0(new o.BKK(50,50),new o.xoR({color:255,side:o.Wl3}))),I[K].position.set(0,0,-25),I[K++].receiveShadow=!0,I.push(new o.Kj0(new o.BKK(50,50),new o.xoR({color:65280,side:o.Wl3}))),I[K].position.set(-25,0,0),I[K].rotation.y=Math.PI/2,I[K++].receiveShadow=!0,I.push(new o.Kj0(new o.BKK(50,50),new o.xoR({color:65280,side:o.Wl3}))),I[K].position.set(25,0,0),I[K].rotation.y=-Math.PI/2,I[K++].receiveShadow=!0,I.push(new o.Kj0(new o.BKK(50,50),new o.xoR({color:255,side:o.Wl3}))),I[K].position.set(0,0,25),I[K].rotation.y=Math.PI,I[K++].receiveShadow=!0,I).forEach((function(e){return c.add(e)})),function(){var e=[16711680,11206400,11184640,41120,16776960],t=0,n=new o.Kj0(new o.XZw(10,3,200,50),new o.xoR({color:e[t++],specular:1}));n.scale.multiplyScalar(.6),n.position.set(-5,-10,5),n.castShadow=!0,n.receiveShadow=!0;var i=new o.Kj0(new o.XZw(10,3,200,50),new o.xoR({color:e[t++],specular:1}));i.scale.multiplyScalar(.5),i.rotation.set(0,Math.PI/2,0),i.position.set(15,5,10),i.castShadow=!0,i.receiveShadow=!0;var r=new o.Kj0(new o.XZw(10,3,200,128),new o.xoR({color:e[t++],specular:1}));r.scale.multiplyScalar(.5),r.rotation.set(0,Math.PI/2,Math.PI/2),r.rotation.set(0,0,Math.PI/2),r.position.set(-15,5,10),r.castShadow=!0,r.receiveShadow=!0;var a=new o.Kj0(new o.Aip(5,32,32),new o.xoR({color:e[t++],specular:1}));a.position.set(5,-15,15),a.castShadow=!0,a.receiveShadow=!0;var s=new o.Kj0(new o.Aip(5,32,32),new o.xoR({color:e[t++],specular:1}));return s.scale.multiplyScalar(1.5),s.position.set(-10,-5,-15),s.castShadow=!0,s.receiveShadow=!0,[n,i,r,a,s]}().forEach((function(e){c.add(e)})),function(e,t){(new r.y).load(a,(function(n){var i=new o.Xcj(n);i.clipAction(n.animations[0]).play(),function(e){e.scale.multiplyScalar(.2),e.position.set(5,-25,-10)}(n);var r=new o.ZAu;r.add(n),n.traverse((function(e){e.isMesh&&(e.castShadow=!0,e.receiveShadow=!0)})),e.add(r),t.push(i)}))}(c,M),function e(){requestAnimationFrame(e);var t=window.performance.now(),n=t-E;E=t,j+=.001*n,w.x=10*Math.sin(j),w.z=10*Math.cos(j)+4,w.y=Math.cos(j)*Math.sin(j)*10,p.position.copy(w),M.length&&M.forEach((function(e){return e.update(n/1e3)})),x.update(),f.render()}()}},0,[[37,666,216]]]);